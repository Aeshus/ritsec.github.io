---
title: A Look at AFL++ Under The Hood
author:
    - Sharad Khanna
date: 2023-04-13
---

## How this post is structured

The objective of this post is to allow anyone to gain an understanding of AFL at the level they want. I want to cover AFL at both a usage level and an internals level.

At the end of this article, there are In-Depth sections that cover AFL in even more depth.

One additional note. In the code snippets, I often use `...` to replace certain code. This is to increase readability by eliminating the edge case code. I have linked the source code on all code snippets if you are interested in reading that code.

This is not a user’s guide to AFL. For that, I highly recommend checking out [Fuzzing101](https://github.com/antonio-morales/Fuzzing101) by GitHub Security Lab. This post is more targeted at those interested in hacking on AFL or learning a little bit more about the world’s favorite fuzzer.

**Disclaimer: I not a developer on the AFL++ project. This is just my analysis of the source code.**

## What is AFL++ and Coverage-Based Fuzzing?

AFL, or the current variation AFL++, is a state-of-the-art fuzzer used to fuzz a wide variety of binaries. Almost every fuzzing campaign today is done using AFL or some variation of AFL.

AFL is not a random-input fuzzer. AFL does something called coverage-based fuzzing. The idea behind coverage-based fuzzing is to keep track of what areas of the binary are executing or coverage. By keeping track of this information, we are able to figure out which inputs lead to which parts of the code executing. With this, we can develop a database of inputs that cover not only a small subset of the codebase but the entire codebase. This would allow us to find errors everywhere in the code, not only in the most commonly used codepaths.

However, how do we build that database of inputs - or **corpus**? The answer is iteration. Typically, we start with a few manually generated seed inputs. These seed inputs are then **mutated** (Randomly changed) to see if they cause a change in coverage. If they cause a change in coverage (Among other potential factors), they are deemed interesting and stored in our corpus for further mutation. Eventually, after iteratively mutating on our growing corpus, we will have a corpus that covers the entire codebase.

Hopefully, we will be able to mutate an input in such a way that we will generate an error in the codepath targeted by that input.

Let’s see an example of coverage given some example code:

```c
int main(){
	input = get_input(); //stub that represents getting the input. Could be via a file, via stdin, or some other means.
	if(condition A){
		...code A...
	}else if(condition B){
		...code B ..
	}else{
		...code C...
	}
	return 0;
}
```

Suppose we enter our seed input into the program. This input - `seed` - leads to `code C` being executed.

Suppose we then mutate seed in some way to generate seed_A. This seed_A, upon being inputted, leads to code A being executed. This is new. With the knowledge that seed_A leads to code A being executed, we can store seed_A in our corpus and mutate it further to allow for new, different code to execute.

This iterative process of finding new, “interesting” input and building on it is what makes coverage-based fuzzing so powerful.
